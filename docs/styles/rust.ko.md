# Rust Style Guide

이 문서는 Rust 코딩 스타일 가이드입니다.

---

## 1. 저수준

### 원칙
- unsafe 범위는 최소화한다
- safe API로 래핑한다
- 저수준 데이터 구조에서 raw 포인터 사용은 허용한다

### 규칙
- unsafe 블록은 필요한 최소 범위로 제한한다
- 모든 unsafe 블록에 `// SAFETY:` 주석을 작성한다
- nullable하지 않은 포인터는 `NonNull<T>`로 래핑한다
- raw 포인터 연산 후 즉시 검증한다: null 체크, bounds 체크, 실패 시 자원 정리
- 자기 참조 구조(트리, 그래프)에서는 `*mut T`, `*const T`를 사용한다
- safe 코드로 대체 가능하면 safe 코드를 사용한다

### 판단 기준: Raw 포인터 vs Box/Rc/Arc
| 상황 | 선택 |
|------|------|
| 자기 참조 구조 (트리, 링크드 리스트) | `*mut T` + `NonNull` |
| 단일 소유권, 힙 할당 | `Box<T>` |
| 공유 소유권, 단일 스레드 | `Rc<T>` |
| 공유 소유권, 멀티 스레드 | `Arc<T>` |
| FFI 경계 | `*mut T` / `*const T` |

### 코드 리뷰 체크리스트
- [ ] unsafe 블록이 필요한 최소 범위로 제한되었는가?
- [ ] 모든 unsafe 블록에 `// SAFETY:` 주석이 있는가?
- [ ] `NonNull`을 사용할 수 있는 곳에 raw 포인터만 쓰고 있지 않은가?
- [ ] raw 포인터 참조 전 null/validity 검증이 있는가?
- [ ] `unsafe impl Send/Sync`의 안전성 근거가 명시되었는가?
- [ ] safe API로 래핑하여 외부에 노출하는가?
- [ ] 실패 경로에서 할당된 리소스가 정리되는가?
- [ ] Box 대신 raw 포인터가 필요한 상황인가? (자기 참조, FFI 등)

---

## 2. 에러 처리

### 원칙
- 에러는 전파한다. `?` 연산자를 사용한다
- 에러 타입은 구체적으로 정의한다
- panic은 최후의 수단이다

### 규칙
- 에러 전파를 기본으로 한다: `?` 연산자 사용
- 모든 에러 타입에 `thiserror` 크레이트의 `#[derive(Error)]`를 적용한다
- 에러 타입은 모듈별 enum으로 정의한다
- 하위 에러를 상위 에러로 변환할 때 `#[from]`을 사용한다
- 에러 메시지는 소문자로 시작한다: `"out of memory"`, `"invalid argument"`
- Result 반환 시 명시적 타입을 사용한다
- 구체적 에러 타입을 정의하고, `Box<dyn Error>`는 사용하지 않는다
- 문자열 에러(`String`, `&str`) 대신 enum variant를 사용한다

### 상황별 에러 처리 방식
| 상황 | 처리 방식 |
|------|----------|
| 일반 로직 | `Result` + `?` 전파 |
| 테스트 코드 | `unwrap()` 허용 |
| 내부 불변성 위반 (버그) | `unreachable!` 허용 |
| 프로그램 시작 시 필수 설정 실패 | `panic!` 허용 |

### 코드 리뷰 체크리스트
- [ ] `unwrap()`/`expect()` 대신 `?` 전파로 대체 가능한가?
- [ ] 모든 에러 타입이 `thiserror::Error`를 derive하는가?
- [ ] 에러 메시지가 소문자로 시작하는가?
- [ ] `#[from]`을 통한 에러 변환이 적절히 설정되었는가?
- [ ] panic 사용이 허용 범위 내인가?

---

## 3. 타입 시스템

### 원칙
- 타입으로 상태를 표현한다
- 컴파일 타임에 오류를 잡는다

### 규칙
- 상호 배타적 상태는 enum으로 표현한다
- bool 플래그 대신 enum variant를 사용한다
- 매직 넘버 대신 const나 enum을 사용한다
- 복잡한 제네릭 타입은 타입 별칭으로 단순화한다
- 마커/토큰 타입은 unit struct로 정의한다
- 구현체 분기는 `#[cfg(feature = "...")]`를 사용한다

### 코드 리뷰 체크리스트
- [ ] 상호 배타적 상태가 enum으로 표현되었는가?
- [ ] bool 플래그가 상태 표현에 사용되고 있지 않은가?
- [ ] 매직 넘버가 const나 enum으로 대체되었는가?
- [ ] 복잡한 제네릭 타입에 타입 별칭이 적용되었는가?
- [ ] Feature flag 조건부 컴파일이 적절한가?

---

## 4. Trait 설계

### 원칙
- 하나의 trait은 하나의 역할만 담당한다
- trait 조합으로 복합 기능을 표현한다

### 규칙
- trait은 단일 책임을 갖도록 작게 유지한다
- 복합 기능은 trait 상속으로 조합한다: `trait Stream: Readable + Writable {}`
- 공통 구현은 blanket implementation을 활용한다: `impl<T: Readable + Writable> Stream for T {}`
- trait bound는 실제로 사용하는 것만 명시한다
- 기능 확장이 필요하면 Layer 패턴(wrapper trait)을 사용한다

### 코드 리뷰 체크리스트
- [ ] trait이 단일 책임을 가지는가?
- [ ] trait의 메서드가 과도하면 분리를 고려했는가?
- [ ] trait bound가 실제 사용되는 것만 포함하는가?
- [ ] blanket implementation으로 중복 구현을 줄일 수 있는가?

---

## 5. Lifetime

### 원칙
- 수명은 최대한 생략한다
- 수명이 복잡해지면 소유권으로 재설계한다

### 규칙
- 컴파일러의 수명 생략 규칙이 적용되면 명시적 수명을 작성하지 않는다
- 구조체 내 참조는 수명을 명시한다
- 전역 상태, 스레드 간 공유 데이터는 `'static`을 사용한다
- 수명 파라미터가 3개 이상 필요하면 소유권 기반으로 재설계한다

### 코드 리뷰 체크리스트
- [ ] 수명 생략 규칙이 적용 가능한 곳에 명시적 수명이 있지 않은가?
- [ ] 수명 파라미터가 3개 이상이면 소유권 기반 재설계를 고려했는가?
- [ ] `'static`이 전역/스레드 공유 맥락에서만 사용되었는가?

---

## 6. 동시성

### 원칙
- 가벼운 동기화를 선호한다: Atomic > Mutex
- 전역 초기화는 `OnceLock`을 사용한다

### 규칙
- 전역 초기화는 `OnceLock`을 사용한다 (`lazy_static!` 대신)
- 스레드별 상태는 `thread_local!`을 사용한다
- 단순 카운터, 플래그는 `Atomic*`을 사용한다
- 복합 상태 변경은 `Mutex`를 사용한다

### 동기화 프리미티브 선택 기준
| 상황 | 선택 |
|------|------|
| 단순 값 증감, 플래그 | `AtomicUsize`, `AtomicBool` |
| 읽기 많고 쓰기 적음 | `RwLock` |
| 읽기/쓰기 빈도 비슷 | `Mutex` |
| 전역 일회성 초기화 | `OnceLock` |
| 스레드별 독립 상태 | `thread_local!` |

### 코드 리뷰 체크리스트
- [ ] `lazy_static!` 대신 `OnceLock`이 사용되었는가?
- [ ] `Mutex` vs `RwLock` 선택이 접근 패턴에 적합한가?
- [ ] 스레드별 독립 상태에 `thread_local!`이 사용되었는가?

---

## 7. 구조체와 열거형

### 원칙
- 모든 타입에 `Debug`를 derive한다
- 필드 가시성은 용도에 맞게 선택한다

### 규칙
- 모든 타입에 `Debug`를 derive한다
- FFI 구조체는 `#[repr(C)]`를 명시한다
- 불변성 검증이 필요한 필드만 private + 메서드로 보호한다

### 코드 리뷰 체크리스트
- [ ] `Debug`가 모든 타입에 derive되어 있는가?
- [ ] FFI 구조체에 `#[repr(C)]`가 있는가?

---

## 8. 모듈 구조

### 원칙
- Rust 2018+ 스타일 모듈 구조를 따른다
- public API는 명시적으로 re-export한다

### 규칙
- 모듈 파일은 `foo.rs` + `foo/bar.rs` 구조를 사용한다 (`mod.rs` 대신)
- public API는 `pub use`로 re-export한다
- 에러 타입은 `error.rs` 모듈에 정의한다
- 선택적 기능은 feature flag로 분리한다

### 예시: 모듈 구조
```
src/
├── lib.rs
├── error.rs
├── stream.rs
└── stream/
    ├── writer.rs
    └── reader.rs
```

### 코드 리뷰 체크리스트
- [ ] `mod.rs` 대신 `파일명.rs` 패턴을 사용하는가?
- [ ] public API가 `pub use`로 re-export되어 있는가?
- [ ] feature flag 조건부 컴파일이 적절한가?

---

## 9. 매크로

### 원칙
- 함수나 제네릭으로 가능하면 매크로를 사용하지 않는다
- 표준 라이브러리 매크로(`debug_assert!`, `unreachable!` 등)는 적극 활용한다

### 규칙
- 커스텀 매크로 정의보다 함수/제네릭을 우선한다
- 내부 불변성 검증은 `debug_assert!`를 사용한다
- 도달 불가능한 분기는 `unreachable!`을 사용하고 메시지를 명시한다
- 매크로가 필요한 경우: 가변 인자, 컴파일 타임 코드 생성, boilerplate 제거

### 코드 리뷰 체크리스트
- [ ] 커스텀 매크로가 함수/제네릭으로 대체 가능하지 않은가?
- [ ] `debug_assert!`가 내부 불변성 검증에 사용되었는가?
- [ ] `unreachable!`에 디버깅 가능한 메시지가 있는가?

---

## 10. 테스트

### 원칙
- 단위 테스트는 같은 파일에, 통합 테스트는 `tests/` 디렉토리에 작성한다
- 테스트 이름만으로 무엇을 검증하는지 알 수 있어야 한다
- 의미 있는 테스트만 작성한다

### 규칙
- 단위 테스트는 `#[cfg(test)] mod tests` 블록에 작성한다
- 통합 테스트는 `tests/` 디렉토리에 작성한다
- 테스트 이름은 검증 대상을 포함한다
- edge case(경계값, 빈 입력, 오버플로우)를 테스트한다
- 자명한 코드(단순 getter, trivial 로직)는 테스트하지 않는다
- 구현 세부사항이 아닌 동작(behavior)을 테스트한다

### 코드 리뷰 체크리스트
- [ ] 테스트 이름만으로 무엇을 검증하는지 알 수 있는가?
- [ ] edge case가 테스트되었는가?
- [ ] 자명한 코드를 테스트하고 있지 않은가?
- [ ] 구현 세부사항이 아닌 동작을 테스트하는가?

---

## 11. 문서화

### 원칙
- 주석은 "왜"를 설명한다 (코드가 "무엇"을 설명)
- 자명한 코드에는 주석을 달지 않는다

### 규칙
- 공개 API는 `///` 문서 주석을 작성한다
- 코드 내 주석은 구현 이유, 비직관적 결정을 설명한다
- 미완성 작업은 `// TODO: 설명`으로 표시한다
- 주석은 코드와 동기화한다 (outdated 주석은 삭제)

### 좋은 예시
```rust
/// 큐에서 항목을 제거하고 반환한다.
/// 큐가 비어있으면 `None`을 반환한다.
pub fn pop(&mut self) -> Option { ... }

// 좋음: "왜"를 설명
// capacity를 2의 거듭제곱으로 유지해야 비트 연산으로 인덱스 계산 가능
let capacity = len.next_power_of_two();
```

### 코드 리뷰 체크리스트
- [ ] 공개 API에 문서 주석이 있는가?
- [ ] 주석이 "왜"를 설명하는가?
- [ ] 주석이 코드와 일치하는가?
- [ ] TODO에 충분한 컨텍스트가 있는가?

